{"version":3,"file":"HtmlToJsonParser.js","sourceRoot":"","sources":["../src/HtmlToJsonParser.ts"],"names":[],"mappings":"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","sourcesContent":["import Piece from \"./piece\";\r\nclass HtmlToJsonParser {\r\n    private htmlString: string;\r\n    private doc: Document;\r\n    constructor(htmlString: string) {\r\n        this.htmlString = htmlString;\r\n        this.doc = new DOMParser().parseFromString(htmlString, \"text/html\");\r\n    }\r\n\r\n    public parse(): any[] {\r\n        const elements = this.doc.body.children;\r\n        let jsonData: any[] = [];\r\n\r\n        Array.from(elements).forEach((element, i) => {\r\n            const _element = this.parseElement(element as HTMLElement)\r\n            console.log(element, 'element parse', i, _element)\r\n            jsonData.push(_element);\r\n        });\r\n        console.log(jsonData, \"element--jsondata\")\r\n        return jsonData;\r\n    }\r\n\r\n    private parseElement(element: HTMLElement): any {\r\n        const dataId = element.getAttribute(\"data-id\") || \"\";\r\n        const className = element.className || \"paragraph-block\";\r\n        const alignment = element.style.textAlign || \"left\";\r\n\r\n        let listType = null;\r\n        let listStart = null;\r\n        let parentId = null;\r\n\r\n        if (element.tagName === \"UL\") {\r\n            listType = \"ul\";\r\n        } else if (element.tagName === \"OL\") {\r\n            listType = \"ol\";\r\n            listStart = parseInt(element.getAttribute(\"start\") || \"1\", 10);\r\n        }\r\n\r\n        let pieces: any[] = [];\r\n\r\n        if (listType) {\r\n            this.parseListItems(element, pieces);\r\n        } else {\r\n            this.parseParagraphText(element, pieces);\r\n        }\r\n\r\n        return {\r\n            dataId,\r\n            class: className,\r\n            alignment,\r\n            pieces,\r\n            ...(listType ? { listType } : {}),  // Only spread if listType exists\r\n            ...(listStart !== null ? { listStart } : {}),  // Only spread if listStart exists\r\n            ...(parentId !== null ? { parentId } : {}),  // Only spread if parentId is not null\r\n        };\r\n    }\r\n\r\n    private parseListItems(element: HTMLElement, pieces: any[]): void {\r\n        const listItems = element.querySelectorAll(\"li\");\r\n        listItems.forEach((li) => {\r\n            const piece = this.extractTextAttributes(li);\r\n\r\n            if (piece) pieces.push(new Piece(piece.text, piece.attributes));\r\n        });\r\n    }\r\n\r\n    // private parseParagraphText(element: HTMLElement, pieces: any[]): void {\r\n    //     const spans = element.querySelectorAll(\"span\");\r\n    //     spans.forEach((span, i) => {\r\n    //         const piece = this.extractTextAttributes(span);\r\n    //         console.log(span, i, \"parseParagraphText\", piece)\r\n\r\n    //         if (piece) pieces.push(new Piece(piece.text, piece.attributes));\r\n    //     });\r\n    //     console.log(pieces, \"pieces--parseParagraphText\")\r\n    // }\r\n    // private parseParagraphText(element: HTMLElement, pieces: any[]): void {\r\n    //     const spans = element.querySelectorAll(\"span\");\r\n\r\n    //     spans.forEach((span) => {\r\n    //         const piece = this.extractTextAttributes(span);\r\n    //         console.log(piece, \"piece parseParagraphText span\", span.textContent, span.style.color)\r\n    //         if (piece) {\r\n    //             // Check if the same text and attributes already exist\r\n    //             let _clonePieces;\r\n    //             const isDuplicate = pieces.some(\r\n    //                 (existing) => {\r\n    //                     _clonePieces = { ...piece };\r\n    //                     console.log(pieces, existing.text, piece.text, piece.attributes, \"parseParagraphText :: \", JSON.stringify(existing.attributes), JSON.stringify(piece.attributes))\r\n    //                     return existing.text === piece.text\r\n    //                     // &&\r\n    //                     // existing.attributes.bold === piece.attributes.bold\r\n    //                     // JSON.stringify(existing.attributes) === JSON.stringify(piece.attributes)\r\n    //                 }\r\n    //             );\r\n    //             console.log(span.textContent, span.style.color, piece, \"parseParagraphText :isDuplicate: \", isDuplicate)\r\n    //             if (!isDuplicate) {\r\n    //                 // console.log(span.textContent, span.style.color, piece, piece.text, piece.attributes, \"parseParagraphText :: \", isDuplicate)\r\n    //                 const _piece = new Piece(piece.text, piece.attributes)\r\n    //                 pieces.push(_piece);\r\n    //             }\r\n    //         }\r\n    //     });\r\n\r\n    //     console.log(pieces, \"pieces--parseParagraphText\");\r\n    // }\r\n    private parseParagraphText(element: HTMLElement, pieces: any[]): void {\r\n        const spans = element.querySelectorAll(\"span\");\r\n        const uniquePieces: Map<string, any> = new Map(); // Use a Map to track unique text entries\r\n\r\n        spans.forEach((span) => {\r\n            const piece = this.extractTextAttributes(span);\r\n            console.log(piece, \"piece parseParagraphText span\", span.textContent, span.style.color);\r\n\r\n            if (piece) {\r\n                const existingPiece = uniquePieces.get(piece.text);\r\n\r\n                if (existingPiece) {\r\n                    // Merge attributes of duplicate text entries\r\n                    existingPiece.attributes.bold = existingPiece.attributes.bold || piece.attributes.bold;\r\n                    existingPiece.attributes.italic = existingPiece.attributes.italic || piece.attributes.italic;\r\n                    existingPiece.attributes.underline = existingPiece.attributes.underline || piece.attributes.underline;\r\n                    existingPiece.attributes.fontFamily = piece.attributes.fontFamily || existingPiece.attributes.fontFamily;\r\n                    existingPiece.attributes.fontSize = piece.attributes.fontSize || existingPiece.attributes.fontSize;\r\n                    existingPiece.attributes.fontColor = piece.attributes.fontColor || existingPiece.attributes.fontColor;\r\n                    existingPiece.attributes.bgColor = piece.attributes.bgColor || existingPiece.attributes.bgColor;\r\n                } else {\r\n                    uniquePieces.set(piece.text, { ...piece });\r\n                }\r\n            }\r\n        });\r\n\r\n        // Convert Map values to an array and push them into pieces\r\n        uniquePieces.forEach((uniquePiece) => {\r\n            pieces.push(new Piece(uniquePiece.text, uniquePiece.attributes));\r\n        });\r\n\r\n        console.log(pieces, \"pieces--parseParagraphText (merged)\");\r\n    }\r\n\r\n    private extractTextAttributes(node: any): any {\r\n        const text = node.textContent || \"\";\r\n        if (!text) return null;\r\n        console.log(\"extractTextAttributes node\", node, node.style.color)\r\n        return {\r\n            text,\r\n            attributes: {\r\n                bold: node.querySelector(\"b, strong\") !== null,\r\n                italic: node.querySelector(\"i, em\") !== null,\r\n                underline: node.querySelector(\"u\") !== null,\r\n                undo: false,\r\n                redo: false,\r\n                fontFamily: node.style.fontFamily || \"Arial\",\r\n                fontSize: node.style.fontSize || \"12px\",\r\n                hyperlink: node.querySelector(\"a\") ? node.querySelector(\"a\")?.getAttribute(\"href\") : false,\r\n                // fontColor: this.rgbToHex(node.style.color, false),\r\n                // bgColor: this.rgbToHex(node.style.backgroundColor, true),\r\n                fontColor: node.style.color,\r\n                bgColor: node.style.backgroundColor,\r\n            },\r\n        };\r\n    }\r\n\r\n    // private rgbToHex(rgb: string): string {\r\n    //     const rgbArray = rgb.match(/\\d+/g);\r\n    //     if (!rgbArray) return \"#000000\";\r\n    //     return `#${rgbArray.map((x) => parseInt(x).toString(16).padStart(2, \"0\")).join(\"\")}`;\r\n    // }\r\n    // private rgbToHex(rgb: string): string {\r\n    //     // Extract numbers from the RGB string using a more robust regex\r\n    //     const rgbArray = rgb.match(/\\d+/g);\r\n\r\n    //     // If no numbers are found, return a default color (e.g., black)\r\n    //     if (!rgbArray || rgbArray.length < 3) return \"#000000\";\r\n\r\n    //     // Convert each RGB component to a 2-digit hexadecimal string\r\n    //     const hex = rgbArray\r\n    //         .map((x) => {\r\n    //             const value = parseInt(x);\r\n    //             // Ensure the value is within the 0-255 range\r\n    //             if (value < 0 || value > 255) return \"00\";\r\n    //             return value.toString(16).padStart(2, \"0\");\r\n    //         })\r\n    //         .join(\"\");\r\n\r\n    //     return `#${hex}`;\r\n    // }\r\n    private rgbToHex(rgb: string, isBackground: boolean = false): string | null {\r\n        // Extract numbers from the RGB string using regex\r\n        const rgbArray = rgb.match(/\\d+/g);\r\n\r\n        // If no numbers are found, return null (no color)\r\n        if (!rgbArray || rgbArray.length < 3) return null;\r\n\r\n        // Convert each RGB component to a 2-digit hexadecimal string\r\n        const hex = rgbArray\r\n            .map((x) => {\r\n                const value = parseInt(x);\r\n                // Ensure the value is within the 0-255 range\r\n                if (value < 0 || value > 255) return \"00\";\r\n                return value.toString(16).padStart(2, \"0\");\r\n            })\r\n            .join(\"\");\r\n\r\n        // Avoid setting default font color as black\r\n        if (!isBackground && hex === \"000000\") {\r\n            return null; // Return null to indicate default color\r\n        }\r\n\r\n        return `#${hex}`;\r\n    }\r\n\r\n}\r\n\r\nexport default HtmlToJsonParser;\r\n// Example Usage:\r\n// const htmlInput = `<div data-id=\"data-id-1734604240404\" class=\"paragraph-block\" style=\"text-align: left;\">\r\n//     <span style=\"font-family: Arial; font-size: 12px; background-color: rgb(160, 39, 39); color: rgb(255, 255, 255);\">\r\n//         ajsh diujaksd\r\n//     </span>\r\n// </div>`;\r\n\r\n// const parser = new HtmlToJsonParser(htmlInput);\r\n// const jsonOutput = parser.parse();\r\n// console.log(JSON.stringify(jsonOutput, null, 2));\r\n"]}