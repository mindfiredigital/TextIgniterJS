<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Headless Text Formatting Demo</title>
    <style>
      body {
        font-family: sans-serif;
        margin: 20px;
      }
      h2 {
        margin-bottom: 10px;
      }

      .toolbar {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 10px;
        position: relative;
      }

      button {
        padding: 8px 10px;
        border: 1px solid #ccc;
        border-radius: 6px;
        background-color: #f8f8f8;
        cursor: pointer;
        font-size: 18px;
        transition: background 0.2s;
        position: relative;
      }

      button:hover {
        background-color: #e6e6e6;
      }

      #editor {
        border: 1px solid #ccc;
        padding: 10px;
        min-height: 150px;
        white-space: pre-wrap;
        border-radius: 6px;
        margin-bottom: 20px;
      }

      pre {
        background: #f6f6f6;
        padding: 10px;
        border-radius: 6px;
        white-space: pre-wrap; /* Allow wrapping */
        word-wrap: break-word; /* Break long words */
        overflow-wrap: break-word; /* Modern browsers */
        overflow-x: auto; /* Horizontal scroll if needed */
        max-width: 100%; /* Don't exceed container */
      }

      .underline {
        text-decoration: underline;
      }
      .strike {
        text-decoration: line-through;
      }

      #colorIndicator {
        width: 18px;
        height: 4px;
        background: black;
        border-radius: 2px;
        display: block;
        margin: 3px auto 0;
      }

      #resetColor {
        font-size: 14px;
        position: absolute;
        right: -10px;
        top: -6px;
        cursor: pointer;
      }

      /* âœ… Native color input always to right of button (same as main editor) */
      #fixedColorInput {
        position: absolute;
        left: calc(100% + 6px); /* just to the right */
        top: 0;
        width: 32px;
        height: 32px;
        opacity: 0; /* invisible but clickable when triggered */
        border: none;
        margin: 0;
        padding: 0;
        cursor: pointer;
        pointer-events: none; /* hidden until we manually trigger it */
      }

      /* make sure button group is stable */
      .color-wrapper {
        position: relative;
        display: inline-block;
      }

      /* Font size dropdown */
      #fontSizeSelect {
        padding: 8px 10px;
        border: 1px solid #ccc;
        border-radius: 6px;
        background-color: #f8f8f8;
        cursor: pointer;
        font-size: 14px;
        min-width: 80px;
      }

      #fontSizeSelect:hover {
        background-color: #e6e6e6;
      }
    </style>
  </head>

  <body>
    <h2>Headless Text Editor</h2>

    <div class="toolbar">
      <button id="boldBtn"><b>B</b></button>
      <button id="italicBtn"><i>I</i></button>
      <button id="underlineBtn"><span class="underline">U</span></button>
      <button id="strikeBtn"><span class="strike">S</span></button>

      <!-- ðŸŽ¨ Color button group -->
      <div class="color-wrapper">
        <button id="colorBtn" title="Font Color">
          <span style="font-weight: bold">A</span>
          <span id="colorIndicator"></span>
          <span id="resetColor">ðŸ”„</span>
        </button>
        <input type="color" id="fixedColorInput" />
      </div>

      <!-- ðŸ“ Font Size dropdown -->
      <select id="fontSizeSelect" title="Font Size">
        <option value="10px">10px</option>
        <option value="12px">12px</option>
        <option value="14px">14px</option>
        <option value="16px" selected>16px</option>
        <option value="18px">18px</option>
        <option value="20px">20px</option>
        <option value="24px">24px</option>
        <option value="28px">28px</option>
        <option value="32px">32px</option>
        <option value="36px">36px</option>
        <option value="48px">48px</option>
      </select>
    </div>

    <div id="editor" contenteditable="true"></div>

    <h3>HTML Output</h3>
    <pre id="output"></pre>

    <script src="./dist/headless.umd.js"></script>
    <script>
      const {
        initHeadless,
        toggleBold,
        toggleItalic,
        toggleUnderline,
        toggleStrikethrough,
        toggleFontColor,
        setActiveFontColor,
        getActiveFontColor,
        toggleFontSize,
        setActiveFontSize,
        getActiveFontSize,
        getContentHtml,
        updatePlainText,
        getDocForSync,
      } = window.TextIgniterHeadless;

      const editor = document.getElementById('editor');
      const output = document.getElementById('output');
      const colorBtn = document.getElementById('colorBtn');
      const colorInput = document.getElementById('fixedColorInput');
      const colorIndicator = document.getElementById('colorIndicator');
      const resetColor = document.getElementById('resetColor');
      const fontSizeSelect = document.getElementById('fontSizeSelect');

      initHeadless('');

      // Save cursor position before DOM manipulation
      function saveCursorPosition() {
        const selection = window.getSelection();
        if (!selection || selection.rangeCount === 0) return null;

        const range = selection.getRangeAt(0);
        const { start } = getAbsoluteOffsets(editor, selection);
        return start;
      }

      // Restore cursor position after DOM manipulation
      function restoreCursorPosition(position) {
        if (position === null || position === undefined) return;

        const textNodes = getTextNodes(editor);
        let offset = 0;
        let targetNode = null;
        let targetOffset = 0;

        for (const node of textNodes) {
          const nodeLength = node.textContent.length;
          if (offset + nodeLength >= position) {
            targetNode = node;
            targetOffset = position - offset;
            break;
          }
          offset += nodeLength;
        }

        if (targetNode) {
          const range = document.createRange();
          const selection = window.getSelection();
          range.setStart(targetNode, targetOffset);
          range.setEnd(targetNode, targetOffset);
          selection.removeAllRanges();
          selection.addRange(range);
        } else if (textNodes.length > 0) {
          // Position is at the end
          const lastNode = textNodes[textNodes.length - 1];
          const range = document.createRange();
          const selection = window.getSelection();
          range.setStart(lastNode, lastNode.textContent.length);
          range.setEnd(lastNode, lastNode.textContent.length);
          selection.removeAllRanges();
          selection.addRange(range);
        }
      }

      // Helper to get all text nodes in order
      function getTextNodes(element) {
        const textNodes = [];
        const walker = document.createTreeWalker(
          element,
          NodeFilter.SHOW_TEXT,
          null,
          false
        );
        let node;
        while ((node = walker.nextNode())) {
          textNodes.push(node);
        }
        return textNodes;
      }

      function renderFromModel() {
        // Save cursor position before replacing DOM
        const cursorPos = saveCursorPosition();

        const html = getContentHtml();
        editor.innerHTML = html;
        // Escape HTML for safe display in <pre> tag
        output.textContent = html;

        // Restore cursor position after DOM update
        restoreCursorPosition(cursorPos);
      }

      function updateIndicator() {
        colorIndicator.style.background = getActiveFontColor();
      }
      updateIndicator();

      // Track previous text to detect what was added/removed
      let previousText = '';
      let previousCursorPos = 0;

      editor.addEventListener('input', e => {
        const currentText = editor.innerText || editor.textContent || '';
        const selection = window.getSelection();

        // Save cursor position before any DOM manipulation
        let cursorPos = null;
        if (selection && selection.rangeCount > 0) {
          const { start } = getAbsoluteOffsets(editor, selection);
          cursorPos = start;
          previousCursorPos = start;
        }

        // Detect if text was added (length increased)
        if (currentText.length > previousText.length) {
          // Text was added - sync model and render
          syncModelFromEditor();
          renderFromModel();
          // Cursor position is restored in renderFromModel, but we need to adjust it
          // because new text was added, cursor should be after the new text
          if (cursorPos !== null) {
            // Cursor should be at the position where user was typing
            // Since text was added, cursor position should be maintained
            setTimeout(() => restoreCursorPosition(cursorPos), 0);
          }
        } else if (currentText.length < previousText.length) {
          // Text was deleted - sync model
          syncModelFromEditor();
          renderFromModel();
          // Restore cursor to where it should be after deletion
          if (cursorPos !== null) {
            setTimeout(() => restoreCursorPosition(cursorPos), 0);
          }
        } else {
          // Text length same but might have changed - sync
          syncModelFromEditor();
          renderFromModel();
          // Restore cursor position
          if (cursorPos !== null) {
            setTimeout(() => restoreCursorPosition(cursorPos), 0);
          }
        }

        previousText = currentText;
        // Escape HTML for safe display in <pre> tag
        output.textContent = getContentHtml();
      });

      function getAbsoluteOffsets(editorEl, selection) {
        const range = selection.getRangeAt(0);
        const preRange = document.createRange();
        preRange.selectNodeContents(editorEl);
        preRange.setEnd(range.startContainer, range.startOffset);
        const start = preRange.toString().length;
        preRange.setEnd(range.endContainer, range.endOffset);
        const end = preRange.toString().length;
        return { start, end };
      }

      // Sync editor text to model before applying formatting
      // Only sync if model is empty or text has actually changed
      function syncModelFromEditor() {
        const editorText = editor.innerText || editor.textContent || '';

        // Get current model
        const doc = getDocForSync();
        if (!doc) {
          updatePlainText(editorText);
          return;
        }

        const block = doc.blocks.find(b => b.dataId === doc.selectedBlockId);
        if (!block || block.pieces.length === 0) {
          updatePlainText(editorText);
          return;
        }

        // Calculate total text length from existing pieces
        const currentModelTextLength = block.pieces.reduce(
          (sum, p) => sum + p.text.length,
          0
        );
        const currentModelText = block.pieces.map(p => p.text).join('');

        // Only sync if:
        // 1. Model is empty (no text)
        // 2. Text length has changed (user typed/deleted)
        // 3. Text content has changed (user edited)
        if (currentModelTextLength === 0) {
          // Model is empty - sync
          updatePlainText(editorText);
        } else if (editorText.length !== currentModelTextLength) {
          // Text length changed - user typed/deleted
          // updatePlainText will try to preserve existing pieces when possible
          updatePlainText(editorText);
        } else if (editorText !== currentModelText) {
          // Text content changed but length same - update text while preserving structure
          if (block.pieces.length > 1) {
            // Multiple pieces - preserve structure, just update text
            let offset = 0;
            for (const piece of block.pieces) {
              const pieceLength = piece.text.length;
              piece.text = editorText.slice(offset, offset + pieceLength);
              offset += pieceLength;
            }
          } else {
            // Single piece - just update
            block.pieces[0].text = editorText;
          }
        }
        // If text matches exactly, don't sync (preserve formatting)
      }

      function handleToggle(action) {
        const selection = window.getSelection();
        if (!selection || selection.rangeCount === 0) return;

        // Sync model with current editor content before applying formatting
        syncModelFromEditor();

        const { start, end } = getAbsoluteOffsets(editor, selection);
        if (start === end) return;
        switch (action) {
          case 'bold':
            toggleBold(start, end);
            break;
          case 'italic':
            toggleItalic(start, end);
            break;
          case 'underline':
            toggleUnderline(start, end);
            break;
          case 'strike':
            toggleStrikethrough(start, end);
            break;
        }
        renderFromModel();
      }

      document
        .getElementById('boldBtn')
        .addEventListener('click', () => handleToggle('bold'));
      document
        .getElementById('italicBtn')
        .addEventListener('click', () => handleToggle('italic'));
      document
        .getElementById('underlineBtn')
        .addEventListener('click', () => handleToggle('underline'));
      document
        .getElementById('strikeBtn')
        .addEventListener('click', () => handleToggle('strike'));

      // ðŸŽ¨ Fixed-position native color chooser (opens to the right)
      colorBtn.addEventListener('click', () => {
        colorInput.value = getActiveFontColor();
        colorInput.style.pointerEvents = 'auto';
        colorInput.click();
        setTimeout(() => {
          colorInput.style.pointerEvents = 'none';
        }, 300);
      });

      // ðŸŽ¨ Apply color on pick
      colorInput.addEventListener('input', () => {
        const selection = window.getSelection();
        if (!selection || selection.rangeCount === 0) return;

        // Sync model with current editor content before applying formatting
        syncModelFromEditor();

        const { start, end } = getAbsoluteOffsets(editor, selection);
        if (start === end) return;

        const chosenColor = colorInput.value;
        setActiveFontColor(chosenColor);
        updateIndicator();
        toggleFontColor(start, end, chosenColor);
        renderFromModel();
      });

      // ðŸ”„ Reset to black
      resetColor.addEventListener('click', () => {
        setActiveFontColor('#000000');
        updateIndicator();
      });

      // ðŸ“ Font size handling
      // Set initial font size
      fontSizeSelect.value = getActiveFontSize();

      // Update font size when dropdown changes (matches core behavior)
      fontSizeSelect.addEventListener('change', () => {
        const selectedSize = fontSizeSelect.value;

        // Always update active font size (like dropdown value in core)
        setActiveFontSize(selectedSize);

        // Get selection range (matches core getSelectionRange)
        const selection = window.getSelection();
        if (selection && selection.rangeCount > 0) {
          // Sync model with current editor content before applying formatting
          syncModelFromEditor();

          const { start, end } = getAbsoluteOffsets(editor, selection);
          if (start !== end) {
            // Apply font size to selected range (matches core setFontSize)
            toggleFontSize(start, end, selectedSize);
            renderFromModel();
          }
          // If start === end (no selection), just update active size for future typing
        }
        // If no selection, just update active size for future typing
      });

      renderFromModel();
    </script>
  </body>
</html>
