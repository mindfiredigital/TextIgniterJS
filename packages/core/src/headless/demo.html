<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Headless Text Formatting Demo</title>
    <style>
      body {
        font-family: sans-serif;
        margin: 20px;
      }
      h2 {
        margin-bottom: 10px;
      }

      .toolbar {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 10px;
        position: relative;
      }

      button {
        padding: 8px 10px;
        border: 1px solid #ccc;
        border-radius: 6px;
        background-color: #f8f8f8;
        cursor: pointer;
        font-size: 18px;
        transition: background 0.2s;
        position: relative;
      }

      button:hover {
        background-color: #e6e6e6;
      }

      #editor {
        border: 1px solid #ccc;
        padding: 10px;
        min-height: 150px;
        white-space: pre-wrap;
        border-radius: 6px;
        margin-bottom: 20px;
      }

      pre {
        background: #f6f6f6;
        padding: 10px;
        border-radius: 6px;
        white-space: pre-wrap; /* Allow wrapping */
        word-wrap: break-word; /* Break long words */
        overflow-wrap: break-word; /* Modern browsers */
        overflow-x: auto; /* Horizontal scroll if needed */
        max-width: 100%; /* Don't exceed container */
      }

      .underline {
        text-decoration: underline;
      }
      .strike {
        text-decoration: line-through;
      }

      #colorIndicator {
        width: 18px;
        height: 4px;
        background: black;
        border-radius: 2px;
        display: block;
        margin: 3px auto 0;
      }

      #resetColor {
        font-size: 14px;
        position: absolute;
        right: -10px;
        top: -6px;
        cursor: pointer;
      }

      /* ‚úÖ Native color input always to right of button (same as main editor) */
      #fixedColorInput {
        position: absolute;
        left: calc(100% + 6px); /* just to the right */
        top: 0;
        width: 32px;
        height: 32px;
        opacity: 0; /* invisible but clickable when triggered */
        border: none;
        margin: 0;
        padding: 0;
        cursor: pointer;
        pointer-events: none; /* hidden until we manually trigger it */
      }

      /* make sure button group is stable */
      .color-wrapper {
        position: relative;
        display: inline-block;
      }

      /* Font size dropdown */
      #fontSizeSelect {
        padding: 8px 10px;
        border: 1px solid #ccc;
        border-radius: 6px;
        background-color: #f8f8f8;
        cursor: pointer;
        font-size: 14px;
        min-width: 80px;
      }

      #fontSizeSelect:hover {
        background-color: #e6e6e6;
      }

      /* Font family dropdown */
      #fontFamilySelect {
        padding: 8px 10px;
        border: 1px solid #ccc;
        border-radius: 6px;
        background-color: #f8f8f8;
        cursor: pointer;
        font-size: 14px;
        min-width: 150px;
      }

      #fontFamilySelect:hover {
        background-color: #e6e6e6;
      }
    </style>
  </head>

  <body>
    <h2>Headless Text Editor</h2>

    <div class="toolbar">
      <button id="boldBtn"><b>B</b></button>
      <button id="italicBtn"><i>I</i></button>
      <button id="underlineBtn"><span class="underline">U</span></button>
      <button id="strikeBtn"><span class="strike">S</span></button>
      <button id="imageBtn">üñºÔ∏è Image</button>

      <!-- üé® Color button group -->
      <div class="color-wrapper">
        <button id="colorBtn" title="Font Color">
          <span style="font-weight: bold">A</span>
          <span id="colorIndicator"></span>
          <span id="resetColor">üîÑ</span>
        </button>
        <input type="color" id="fixedColorInput" />
      </div>

      <!-- üìè Font Size dropdown -->
      <select id="fontSizeSelect" title="Font Size">
        <option value="10px">10px</option>
        <option value="12px">12px</option>
        <option value="14px">14px</option>
        <option value="16px" selected>16px</option>
        <option value="18px">18px</option>
        <option value="20px">20px</option>
        <option value="24px">24px</option>
        <option value="28px">28px</option>
        <option value="32px">32px</option>
        <option value="36px">36px</option>
        <option value="48px">48px</option>
      </select>

      <!-- üî§ Font Family dropdown -->
      <select id="fontFamilySelect" title="Font Family">
        <option value="Arial" selected>Arial</option>
        <option value="Times New Roman">Times New Roman</option>
        <option value="Courier New">Courier New</option>
        <option value="Verdana">Verdana</option>
        <option value="Georgia">Georgia</option>
        <option value="Palatino">Palatino</option>
        <option value="Garamond">Garamond</option>
        <option value="Comic Sans MS">Comic Sans MS</option>
        <option value="Trebuchet MS">Trebuchet MS</option>
        <option value="Impact">Impact</option>
        <option value="Lucida Console">Lucida Console</option>
        <option value="Tahoma">Tahoma</option>
        <option value="Helvetica">Helvetica</option>
      </select>
    </div>

    <div id="editor" contenteditable="true"></div>

    <h3>HTML Output</h3>
    <pre id="output"></pre>

    <script src="./dist/headless.umd.js"></script>
    <script>
      const {
        initHeadless,
        toggleBold,
        toggleItalic,
        toggleUnderline,
        toggleStrikethrough,
        toggleFontColor,
        setActiveFontColor,
        getActiveFontColor,
        toggleFontSize,
        setActiveFontSize,
        getActiveFontSize,
        toggleFontFamily,
        setActiveFontFamily,
        getActiveFontFamily,
        getContentHtml,
        updatePlainText,
        getDocForSync,
        insertImageAtPosition,
        deleteImageBlock,
      } = window.TextIgniterHeadless;

      const editor = document.getElementById('editor');
      const output = document.getElementById('output');
      const colorBtn = document.getElementById('colorBtn');
      const colorInput = document.getElementById('fixedColorInput');
      const colorIndicator = document.getElementById('colorIndicator');
      const resetColor = document.getElementById('resetColor');
      const fontSizeSelect = document.getElementById('fontSizeSelect');
      const fontFamilySelect = document.getElementById('fontFamilySelect');

      initHeadless('');

      // Save cursor position before DOM manipulation
      function saveCursorPosition() {
        const selection = window.getSelection();
        if (!selection || selection.rangeCount === 0) return null;

        const range = selection.getRangeAt(0);
        const { start } = getAbsoluteOffsets(editor, selection);
        return start;
      }

      // Restore cursor position after DOM manipulation
      function restoreCursorPosition(position) {
        if (position === null || position === undefined) return;

        const textNodes = getTextNodes(editor);
        let offset = 0;
        let targetNode = null;
        let targetOffset = 0;

        for (const node of textNodes) {
          const nodeLength = node.textContent.length;
          if (offset + nodeLength >= position) {
            targetNode = node;
            targetOffset = position - offset;
            break;
          }
          offset += nodeLength;
        }

        if (targetNode) {
          const range = document.createRange();
          const selection = window.getSelection();
          range.setStart(targetNode, targetOffset);
          range.setEnd(targetNode, targetOffset);
          selection.removeAllRanges();
          selection.addRange(range);
        } else if (textNodes.length > 0) {
          // Position is at the end
          const lastNode = textNodes[textNodes.length - 1];
          const range = document.createRange();
          const selection = window.getSelection();
          range.setStart(lastNode, lastNode.textContent.length);
          range.setEnd(lastNode, lastNode.textContent.length);
          selection.removeAllRanges();
          selection.addRange(range);
        }
      }

      // Helper to get all text nodes in order
      function getTextNodes(element) {
        const textNodes = [];
        const walker = document.createTreeWalker(
          element,
          NodeFilter.SHOW_TEXT,
          null,
          false
        );
        let node;
        while ((node = walker.nextNode())) {
          textNodes.push(node);
        }
        return textNodes;
      }

      function renderFromModel() {
        // Save cursor position before replacing DOM
        const cursorPos = saveCursorPosition();

        const html = getContentHtml();
        editor.innerHTML = html;
        // Escape HTML for safe display in <pre> tag
        output.textContent = html;

        // Restore cursor position after DOM update
        restoreCursorPosition(cursorPos);
      }

      function updateIndicator() {
        colorIndicator.style.background = getActiveFontColor();
      }
      updateIndicator();

      // Track previous text to detect what was added/removed
      let previousText = '';
      let previousCursorPos = 0;

      editor.addEventListener('input', e => {
        const selection = window.getSelection();

        // Save cursor position before any DOM manipulation
        let cursorPos = null;
        if (selection && selection.rangeCount > 0) {
          const { start } = getAbsoluteOffsets(editor, selection);
          cursorPos = start;
          previousCursorPos = start;
        }

        // Get current block element from selection
        let currentBlockElement = null;
        let currentBlockId = null;

        if (selection && selection.rangeCount > 0) {
          let node = selection.anchorNode;
          while (node && node !== editor) {
            if (node.nodeType === Node.ELEMENT_NODE) {
              const element = node;
              const dataId = element.getAttribute('data-id');
              if (dataId) {
                currentBlockElement = element;
                currentBlockId = dataId;
                break;
              }
            }
            node = node.parentNode;
          }
        }

        // Only sync if we're in a text block (not an image block)
        if (currentBlockElement && currentBlockId) {
          const doc = getDocForSync();
          const block = doc.blocks.find(b => b.dataId === currentBlockId);

          // Only sync text blocks, skip image blocks
          if (block && block.type === 'text') {
            // Get text from current block only, not entire editor
            const blockText =
              currentBlockElement.innerText ||
              currentBlockElement.textContent ||
              '';
            const currentModelText = block.pieces.map(p => p.text).join('');

            // Only update if text actually changed
            if (blockText !== currentModelText) {
              // Update the block's text directly
              if (block.pieces.length === 1) {
                // Single piece - just update text
                block.pieces[0].text = blockText;
              } else {
                // Multiple pieces - preserve structure, update text
                let offset = 0;
                for (const piece of block.pieces) {
                  const pieceLength = piece.text.length;
                  piece.text = blockText.slice(offset, offset + pieceLength);
                  offset += pieceLength;
                }
              }

              // Only render if text changed significantly
              if (Math.abs(blockText.length - currentModelText.length) > 0) {
                renderFromModel();
                if (cursorPos !== null) {
                  setTimeout(() => restoreCursorPosition(cursorPos), 0);
                }
              }
            }
          }
        }

        previousText = editor.innerText || editor.textContent || '';
        // Escape HTML for safe display in <pre> tag
        output.textContent = getContentHtml();
      });

      function getAbsoluteOffsets(editorEl, selection) {
        const range = selection.getRangeAt(0);
        const preRange = document.createRange();
        preRange.selectNodeContents(editorEl);
        preRange.setEnd(range.startContainer, range.startOffset);
        const start = preRange.toString().length;
        preRange.setEnd(range.endContainer, range.endOffset);
        const end = preRange.toString().length;
        return { start, end };
      }

      // Sync editor text to model before applying formatting
      // Only sync if model is empty or text has actually changed
      function syncModelFromEditor() {
        const editorText = editor.innerText || editor.textContent || '';

        // Get current model
        const doc = getDocForSync();
        if (!doc) {
          updatePlainText(editorText);
          return;
        }

        const block = doc.blocks.find(b => b.dataId === doc.selectedBlockId);
        if (!block || block.pieces.length === 0) {
          updatePlainText(editorText);
          return;
        }

        // Calculate total text length from existing pieces
        const currentModelTextLength = block.pieces.reduce(
          (sum, p) => sum + p.text.length,
          0
        );
        const currentModelText = block.pieces.map(p => p.text).join('');

        // Only sync if:
        // 1. Model is empty (no text)
        // 2. Text length has changed (user typed/deleted)
        // 3. Text content has changed (user edited)
        if (currentModelTextLength === 0) {
          // Model is empty - sync
          updatePlainText(editorText);
        } else if (editorText.length !== currentModelTextLength) {
          // Text length changed - user typed/deleted
          // updatePlainText will try to preserve existing pieces when possible
          updatePlainText(editorText);
        } else if (editorText !== currentModelText) {
          // Text content changed but length same - update text while preserving structure
          if (block.pieces.length > 1) {
            // Multiple pieces - preserve structure, just update text
            let offset = 0;
            for (const piece of block.pieces) {
              const pieceLength = piece.text.length;
              piece.text = editorText.slice(offset, offset + pieceLength);
              offset += pieceLength;
            }
          } else {
            // Single piece - just update
            block.pieces[0].text = editorText;
          }
        }
        // If text matches exactly, don't sync (preserve formatting)
      }

      function handleToggle(action) {
        const selection = window.getSelection();
        if (!selection || selection.rangeCount === 0) return;

        // Sync model with current editor content before applying formatting
        syncModelFromEditor();

        const { start, end } = getAbsoluteOffsets(editor, selection);
        if (start === end) return;
        switch (action) {
          case 'bold':
            toggleBold(start, end);
            break;
          case 'italic':
            toggleItalic(start, end);
            break;
          case 'underline':
            toggleUnderline(start, end);
            break;
          case 'strike':
            toggleStrikethrough(start, end);
            break;
        }
        renderFromModel();
      }

      document
        .getElementById('boldBtn')
        .addEventListener('click', () => handleToggle('bold'));
      document
        .getElementById('italicBtn')
        .addEventListener('click', () => handleToggle('italic'));
      document
        .getElementById('underlineBtn')
        .addEventListener('click', () => handleToggle('underline'));
      document
        .getElementById('strikeBtn')
        .addEventListener('click', () => handleToggle('strike'));

      // üé® Fixed-position native color chooser (opens to the right)
      colorBtn.addEventListener('click', () => {
        colorInput.value = getActiveFontColor();
        colorInput.style.pointerEvents = 'auto';
        colorInput.click();
        setTimeout(() => {
          colorInput.style.pointerEvents = 'none';
        }, 300);
      });

      // üé® Apply color on pick
      colorInput.addEventListener('input', () => {
        const selection = window.getSelection();
        if (!selection || selection.rangeCount === 0) return;

        // Sync model with current editor content before applying formatting
        syncModelFromEditor();

        const { start, end } = getAbsoluteOffsets(editor, selection);
        if (start === end) return;

        const chosenColor = colorInput.value;
        setActiveFontColor(chosenColor);
        updateIndicator();
        toggleFontColor(start, end, chosenColor);
        renderFromModel();
      });

      // üîÑ Reset to black
      resetColor.addEventListener('click', () => {
        setActiveFontColor('#000000');
        updateIndicator();
      });

      // üìè Font size handling
      // Set initial font size
      fontSizeSelect.value = getActiveFontSize();

      // Update font size when dropdown changes (matches core behavior)
      fontSizeSelect.addEventListener('change', () => {
        const selectedSize = fontSizeSelect.value;

        // Always update active font size (like dropdown value in core)
        setActiveFontSize(selectedSize);

        // Get selection range (matches core getSelectionRange)
        const selection = window.getSelection();
        if (selection && selection.rangeCount > 0) {
          // Sync model with current editor content before applying formatting
          syncModelFromEditor();

          const { start, end } = getAbsoluteOffsets(editor, selection);
          if (start !== end) {
            // Apply font size to selected range (matches core setFontSize)
            toggleFontSize(start, end, selectedSize);
            renderFromModel();
          }
          // If start === end (no selection), just update active size for future typing
        }
        // If no selection, just update active size for future typing
      });

      // üî§ Font family handling
      // Set initial font family
      fontFamilySelect.value = getActiveFontFamily();

      // Update font family when dropdown changes (matches core behavior)
      fontFamilySelect.addEventListener('change', () => {
        const selectedFamily = fontFamilySelect.value;

        // Always update active font family (like dropdown value in core)
        setActiveFontFamily(selectedFamily);

        // Get selection range (matches core getSelectionRange)
        const selection = window.getSelection();
        if (selection && selection.rangeCount > 0) {
          // Sync model with current editor content before applying formatting
          syncModelFromEditor();

          const { start, end } = getAbsoluteOffsets(editor, selection);
          if (start !== end) {
            // Apply font family to selected range (matches core setFontFamily)
            toggleFontFamily(start, end, selectedFamily);
            renderFromModel();
          }
          // If start === end (no selection), just update active family for future typing
        }
        // If no selection, just update active family for future typing
      });

      renderFromModel();

      // Image management: track highlighted image
      let highlightedImageDataId = null;
      let isCrossIconVisible = false;

      // Function to add styling and cross button to image
      function addStyleToImage(dataId) {
        if (!dataId || isCrossIconVisible) return;

        const div = editor.querySelector(`[data-id="${dataId}"]`);
        if (!div) return;

        const span = div.querySelector('span');
        if (span) {
          span.style.position = 'relative';
        }

        const img = div.querySelector('img');
        if (img) {
          img.style.border = '2px solid blue';
        }

        // Create cross button
        const cross = document.createElement('div');
        cross.className = 'image-cross';
        cross.innerHTML = 'x';
        Object.assign(cross.style, {
          position: 'absolute',
          top: '0',
          left: '50%',
          transform: 'translate(-50%, 0)',
          background: '#fff',
          borderRadius: '50%',
          width: '30px',
          height: '30px',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          cursor: 'pointer',
          border: '3px solid blue',
          zIndex: '999',
        });

        cross.addEventListener('mouseover', () => {
          cross.style.border = '3px solid black';
        });

        cross.addEventListener('mouseout', () => {
          cross.style.border = '3px solid blue';
        });

        cross.addEventListener('click', e => {
          e.stopPropagation();
          deleteImage(dataId);
        });

        span?.appendChild(cross);
        highlightedImageDataId = dataId;
        isCrossIconVisible = true;
      }

      // Function to clear image styling
      function clearImageStyling() {
        if (!highlightedImageDataId) return;

        const div = editor.querySelector(
          `[data-id="${highlightedImageDataId}"]`
        );
        if (div) {
          const span = div.querySelector('span');
          if (span) {
            span.removeAttribute('style');
          }

          const img = span?.querySelector('img');
          if (img) {
            img.removeAttribute('style');
          }

          const cross = span?.querySelector('.image-cross');
          if (cross) {
            cross.remove();
          }
        }

        highlightedImageDataId = null;
        isCrossIconVisible = false;
      }

      // Function to delete image
      function deleteImage(dataId) {
        if (!dataId) return;

        // Delete from model
        const html = deleteImageBlock(dataId);

        // Update DOM
        editor.innerHTML = html;
        output.textContent = html;

        // Clear styling
        clearImageStyling();

        // Set cursor in next available block
        const doc = getDocForSync();
        if (doc.selectedBlockId) {
          const newBlockElement = editor.querySelector(
            `[data-id="${doc.selectedBlockId}"]`
          );
          if (newBlockElement) {
            const walker = document.createTreeWalker(
              newBlockElement,
              NodeFilter.SHOW_TEXT,
              null,
              false
            );
            const firstTextNode = walker.nextNode();
            if (firstTextNode) {
              const range = document.createRange();
              range.setStart(firstTextNode, 0);
              range.collapse(true);
              const sel = window.getSelection();
              if (sel) {
                sel.removeAllRanges();
                sel.addRange(range);
              }
            }
          }
        }
      }

      // Add click handler for images (delegated event listener)
      editor.addEventListener('click', e => {
        // Check if clicked on an image
        const img = e.target.closest('img');
        if (img) {
          const blockDiv = img.closest('[data-id]');
          if (blockDiv) {
            const dataId = blockDiv.getAttribute('data-id');
            if (dataId) {
              // Clear previous styling
              clearImageStyling();
              // Add styling to clicked image
              addStyleToImage(dataId);
            }
          }
          return;
        }

        // Check if clicked on cross button
        const cross = e.target.closest('.image-cross');
        if (cross) {
          // Cross button click is handled in addStyleToImage
          return;
        }

        // Clicked elsewhere - clear image styling
        if (isCrossIconVisible) {
          clearImageStyling();
        }
      });

      // Image insertion handler
      const imageBtn = document.getElementById('imageBtn');
      console.log('Image button element:', imageBtn);

      if (imageBtn) {
        imageBtn.addEventListener('click', () => {
          console.log('Image button clicked');

          // IMPORTANT: Save cursor position and block info BEFORE opening file dialog
          let savedCursorInfo = null;
          const selection = window.getSelection();
          
          if (selection && selection.rangeCount > 0) {
            try {
              // Method 1: Use absolute position to find the correct block
              const { start: absoluteCursorPos } = getAbsoluteOffsets(editor, selection);
              console.log('Absolute cursor position in editor:', absoluteCursorPos);
              
              // Sync model to get current state
              syncModelFromEditor();
              const doc = getDocForSync();
              
              // Find which block contains this cursor position
              let accumulatedLength = 0;
              let foundBlock = null;
              let cursorOffsetInBlock = 0;
              
              for (const block of doc.blocks) {
                if (block.type === 'text') {
                  const blockText = block.pieces.map(p => p.text).join('');
                  const blockLength = blockText.length;
                  
                  // Check if cursor is within this block
                  if (absoluteCursorPos >= accumulatedLength && 
                      absoluteCursorPos <= accumulatedLength + blockLength) {
                    foundBlock = block;
                    cursorOffsetInBlock = absoluteCursorPos - accumulatedLength;
                    console.log('Found block containing cursor:', {
                      blockId: block.dataId,
                      blockText: blockText.substring(0, 50) + '...',
                      cursorOffsetInBlock: cursorOffsetInBlock,
                      blockLength: blockLength
                    });
                    break;
                  }
                  
                  accumulatedLength += blockLength;
                  // Account for newlines between blocks (if any)
                  // In contenteditable, blocks are separate divs, so no newline between them
                }
              }
              
              if (foundBlock) {
                savedCursorInfo = {
                  blockId: foundBlock.dataId,
                  cursorOffset: cursorOffsetInBlock,
                };
                console.log('Saved cursor info (absolute position method):', savedCursorInfo);
              } else {
                // Fallback: Use DOM-based calculation
                console.log('Block not found via absolute position, trying DOM method...');
                let node = selection.anchorNode;
                while (node && node !== editor) {
                  if (node.nodeType === Node.ELEMENT_NODE) {
                    const element = node;
                    const dataId = element.getAttribute('data-id');
                    if (dataId) {
                      // Calculate cursor offset relative to this block
                      const range = selection.getRangeAt(0);
                      const blockRange = document.createRange();
                      blockRange.selectNodeContents(element);
                      blockRange.setEnd(range.startContainer, range.startOffset);
                      const cursorOffset = blockRange.toString().length;
                      
                      savedCursorInfo = {
                        blockId: dataId,
                        cursorOffset: cursorOffset,
                      };
                      console.log('Saved cursor info (DOM method):', savedCursorInfo);
                      break;
                    }
                  }
                  node = node.parentNode;
                }
              }
            } catch (error) {
              console.error('Error capturing cursor position:', error);
            }
          }
          
          // Final fallback: use selectedBlockId from model
          if (!savedCursorInfo) {
            syncModelFromEditor();
            const doc = getDocForSync();
            if (doc.selectedBlockId) {
              const block = doc.blocks.find(b => b.dataId === doc.selectedBlockId);
              let cursorOffset = 0;
              if (block && block.type === 'text') {
                // Default to end of block if we can't determine position
                const blockText = block.pieces.map(p => p.text).join('');
                cursorOffset = blockText.length;
              }
              
              savedCursorInfo = {
                blockId: doc.selectedBlockId,
                cursorOffset: cursorOffset,
              };
              console.log('Using fallback cursor info:', savedCursorInfo);
            }
          }

          // Create file input
          const fileInput = document.createElement('input');
          fileInput.type = 'file';
          fileInput.accept = 'image/*';
          fileInput.style.display = 'none';
          document.body.appendChild(fileInput);

          fileInput.click();
          console.log('File input opened');

          fileInput.onchange = () => {
            console.log('File input changed');
            const file = fileInput.files ? fileInput.files[0] : null;
            console.log(
              'Selected file:',
              file
                ? { name: file.name, type: file.type, size: file.size }
                : 'null'
            );

            if (file) {
              const reader = new FileReader();
              reader.onload = e => {
                console.log('FileReader onload triggered');
                const dataUrl = e.target?.result;
                console.log('Data URL type:', typeof dataUrl);
                console.log(
                  'Data URL length:',
                  dataUrl
                    ? typeof dataUrl === 'string'
                      ? dataUrl.length
                      : 'not a string'
                    : 'null'
                );
                console.log(
                  'Data URL preview:',
                  dataUrl && typeof dataUrl === 'string'
                    ? dataUrl.substring(0, 50) + '...'
                    : 'N/A'
                );

                if (dataUrl && typeof dataUrl === 'string') {
                  console.log('Step 1: Syncing model from editor...');
                  // Sync model first to ensure we have latest state
                  syncModelFromEditor();

                  console.log('Step 2: Getting document for sync...');
                  const doc = getDocForSync();
                  console.log('Document blocks:', doc.blocks.length);
                  console.log('Selected block ID:', doc.selectedBlockId);

                  // Use saved cursor info (from before file dialog)
                  let currentBlockId = savedCursorInfo?.blockId || doc.selectedBlockId;
                  let cursorOffset = savedCursorInfo?.cursorOffset || 0;
                  
                  // Verify the block still exists after sync
                  const blockExists = doc.blocks.some(b => b.dataId === currentBlockId);
                  if (!blockExists && doc.blocks.length > 0) {
                    console.warn('Saved block ID not found after sync, using first block');
                    currentBlockId = doc.blocks[0].dataId;
                    cursorOffset = 0;
                  }
                  
                  // If still no block ID, use first block
                  if (!currentBlockId && doc.blocks.length > 0) {
                    currentBlockId = doc.blocks[0].dataId;
                    cursorOffset = 0;
                    console.log('Using fallback block ID:', currentBlockId);
                  }

                  console.log('Final currentBlockId:', currentBlockId);
                  console.log('Final cursorOffset:', cursorOffset);
                  
                  // Log block details for debugging
                  const targetBlock = doc.blocks.find(b => b.dataId === currentBlockId);
                  if (targetBlock) {
                    const blockText = targetBlock.pieces.map(p => p.text).join('');
                    console.log('Target block text:', blockText.substring(0, 100));
                    console.log('Target block length:', blockText.length);
                    console.log('Cursor offset:', cursorOffset);
                    if (cursorOffset > blockText.length) {
                      console.warn('Cursor offset exceeds block length, clamping to end');
                      cursorOffset = blockText.length;
                    }
                  }

                  console.log('Step 5: Calling insertImageAtPosition...');
                  console.log('Parameters:', {
                    dataId: currentBlockId,
                    position: cursorOffset,
                    imageDataUrlLength: dataUrl.length,
                  });

                  // Insert image
                  const html = insertImageAtPosition(
                    currentBlockId,
                    cursorOffset,
                    dataUrl
                  );

                  console.log('Step 6: Image insertion returned HTML');
                  console.log('HTML length:', html.length);
                  console.log('HTML preview:', html.substring(0, 200) + '...');

                  // Update DOM
                  console.log('Step 7: Updating DOM...');
                  editor.innerHTML = html;
                  output.textContent = html;
                  console.log('DOM updated');

                  // Set cursor in the new text block after image
                  console.log('Step 8: Setting cursor position...');
                  const docAfter = getDocForSync();
                  const newBlockId = docAfter.selectedBlockId;
                  console.log('New block ID after insertion:', newBlockId);

                  if (newBlockId) {
                    const newBlockElement = editor.querySelector(
                      `[data-id="${newBlockId}"]`
                    );
                    console.log('New block element found:', !!newBlockElement);

                    if (newBlockElement) {
                      // Find first text node and set cursor
                      const walker = document.createTreeWalker(
                        newBlockElement,
                        NodeFilter.SHOW_TEXT,
                        null,
                        false
                      );
                      const firstTextNode = walker.nextNode();
                      console.log('First text node found:', !!firstTextNode);

                      if (firstTextNode) {
                        const range = document.createRange();
                        range.setStart(firstTextNode, 0);
                        range.collapse(true);
                        const sel = window.getSelection();
                        if (sel) {
                          sel.removeAllRanges();
                          sel.addRange(range);
                          console.log('Cursor set successfully');
                        }
                      }
                    }
                  }

                  console.log('Image insertion complete!');
                } else {
                  console.error('Invalid data URL:', dataUrl);
                }
              };

              reader.onerror = error => {
                console.error('FileReader error:', error);
              };

              console.log('Starting to read file as data URL...');
              reader.readAsDataURL(file);
            } else {
              console.log('No file selected');
            }
            // Clean up
            document.body.removeChild(fileInput);
          };
        });
      } else {
        console.error('Image button not found!');
      }
    </script>
  </body>
</html>
